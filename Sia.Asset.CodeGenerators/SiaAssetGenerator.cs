namespace Sia.Asset.CodeGenerators;

using System.CodeDom.Compiler;
using System.Collections.Immutable;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using static Common;

[Generator]
internal partial class SiaAssetGenerator : IIncrementalGenerator
{
    public static readonly string AttributeName = "SiaAssetAttribute";
    public static readonly string AttributeType = $"Sia.Asset.{AttributeName}";
    private static readonly string ttributeSource = $$"""
// <auto-generated/>
#nullable enable

namespace Sia.Asset;

[{{Common.GeneratedCodeAttribute}}]
[global::System.AttributeUsage(
    global::System.AttributeTargets.Class | global::System.AttributeTargets.Struct,
    Inherited = false, AllowMultiple = false)]
internal sealed class {{AttributeName}} : global::System.Attribute
{
}
""";

    protected record CodeGenerationInfo(
        INamespaceSymbol Namespace,
        ImmutableArray<TypeDeclarationSyntax> ParentTypes,
        TypeDeclarationSyntax RecordTypeSyntax,
        string ComponentType);
    
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        context.RegisterPostInitializationOutput(context => {
            context.AddSource(AttributeName + ".g.cs",
                SourceText.From(ttributeSource, Encoding.UTF8));
        });

        var codeGenInfos = context.SyntaxProvider.ForAttributeWithMetadataName(
            AttributeType,
            static (syntaxNode, token) => true,
            static (syntax, token) =>
                (syntax, ParentTypes: GetParentTypes(syntax.TargetNode)))
            .Where(static t => t.ParentTypes.All(
                static typeDecl => typeDecl.Modifiers.Any(SyntaxKind.PartialKeyword)))
            .Select(static (t, token) => {
                var (syntax, parentTypes) = t;
                var model = syntax.SemanticModel;
                var assetAttr = syntax.Attributes[0];

                var targetTypeSyntax = (TypeDeclarationSyntax)syntax.TargetNode;
                var targetTypeSymbol = (ITypeSymbol)model.GetDeclaredSymbol(targetTypeSyntax)!;

                return new CodeGenerationInfo(
                    Namespace: syntax.TargetSymbol.ContainingNamespace,
                    ParentTypes: parentTypes,
                    RecordTypeSyntax: targetTypeSyntax,
                    ComponentType: FindAssetComponentName(targetTypeSymbol)!
                );
            })
            .Where(static info => info.ComponentType != null);
        
        context.RegisterSourceOutput(codeGenInfos, (context, info) => {
            using var source = CreateSource(out var builder);
            GenerateSource(source, info);
            context.AddSource(GenerateFileName(info), builder.ToString());
        });
    }

    private static string GenerateFileName(CodeGenerationInfo info)
    {
        var builder = new StringBuilder();
        builder.Append(info.Namespace.ToDisplayString());
        builder.Append('.');
        foreach (var parentType in info.ParentTypes) {
            builder.Append(parentType.Identifier.ToString());
            builder.Append('.');
        }
        builder.Append(info.RecordTypeSyntax.Identifier.ToString());
        builder.Append(".g.cs");
        return builder.ToString();
    }

    private void GenerateSource(IndentedTextWriter source, CodeGenerationInfo info)
    {
        source.WriteLine("using Sia;");
        source.WriteLine();

        using (GenerateInNamespace(source, info.Namespace)) {
            using (GenerateInPartialTypes(source, info.ParentTypes)) {
                source.Write("partial record struct ");
                source.Write(info.ComponentType);
                WriteTypeParameters(source, info.RecordTypeSyntax);
                source.Write(" : global::Sia.Asset.IAsset<");
                source.Write(info.ComponentType);
                WriteTypeParameters(source, info.RecordTypeSyntax);
                source.Write(", ");
                WriteType(source, info.RecordTypeSyntax);
                source.WriteLine('>');

                source.WriteLine("{");
                source.Indent++;
                GenerateCreateMethod(source, info);
                source.Indent--;
                source.WriteLine("}");
            }
        }
    }

    private static void GenerateCreateMethod(IndentedTextWriter source, CodeGenerationInfo info)
    {
        source.Write("public static global::Sia.Asset.AssetBundle<");
        source.Write(info.ComponentType);
        WriteTypeParameters(source, info.RecordTypeSyntax);
        source.Write("> Create(");
        WriteType(source, info.RecordTypeSyntax);
        source.WriteLine(" record, global::Sia.Asset.AssetLife life = global::Sia.Asset.AssetLife.Automatic)");

        source.Indent++;
        source.Write("=> global::Sia.Asset.AssetBundle.Create<");
        source.Write(info.ComponentType);
        WriteTypeParameters(source, info.RecordTypeSyntax);
        source.Write(", ");
        WriteType(source, info.RecordTypeSyntax);
        source.WriteLine(">(record, life);");
        source.Indent--;
    }
}